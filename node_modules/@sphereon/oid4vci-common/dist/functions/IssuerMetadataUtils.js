"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIssuerName = exports.getIssuerDisplays = exports.credentialSupportedV8ToV11 = exports.credentialsSupportedV8ToV11 = exports.getTypesFromCredentialSupported = exports.getSupportedCredential = exports.getSupportedCredentials = void 0;
const types_1 = require("../types");
function getSupportedCredentials(opts) {
    if ((opts === null || opts === void 0 ? void 0 : opts.types) && Array.isArray(opts === null || opts === void 0 ? void 0 : opts.types)) {
        return opts.types.flatMap((types) => getSupportedCredential(Object.assign(Object.assign({}, opts), { types })));
    }
    return getSupportedCredential(opts ? Object.assign(Object.assign({}, opts), { types: undefined }) : undefined);
}
exports.getSupportedCredentials = getSupportedCredentials;
function getSupportedCredential(opts) {
    var _a, _b;
    const { issuerMetadata } = opts !== null && opts !== void 0 ? opts : {};
    let formats;
    if ((opts === null || opts === void 0 ? void 0 : opts.format) && Array.isArray(opts.format)) {
        formats = opts.format;
    }
    else if ((opts === null || opts === void 0 ? void 0 : opts.format) && !Array.isArray(opts.format)) {
        formats = [opts.format];
    }
    else {
        formats = [];
    }
    let credentialsSupported;
    if (!issuerMetadata) {
        return [];
    }
    const { version, types } = opts !== null && opts !== void 0 ? opts : { version: types_1.OpenId4VCIVersion.VER_1_0_11 };
    if (version === types_1.OpenId4VCIVersion.VER_1_0_08 || !Array.isArray(issuerMetadata.credentials_supported)) {
        credentialsSupported = credentialsSupportedV8ToV11((_a = issuerMetadata.credentials_supported) !== null && _a !== void 0 ? _a : {});
    }
    else {
        credentialsSupported = issuerMetadata.credentials_supported;
    }
    if (credentialsSupported === undefined || credentialsSupported.length === 0) {
        return [];
    }
    else if (!types || types.length === 0) {
        return credentialsSupported;
    }
    /**
     * the following (not array part is a legacy code from version 1_0-08 which JFF plugfest 2 implementors used)
     */
    let initiationTypes;
    if (opts === null || opts === void 0 ? void 0 : opts.types) {
        if (typeof opts.types === 'string') {
            initiationTypes = [opts.types];
        }
        else {
            initiationTypes = opts.types;
        }
    }
    if (version === types_1.OpenId4VCIVersion.VER_1_0_08 && (!initiationTypes || (initiationTypes === null || initiationTypes === void 0 ? void 0 : initiationTypes.length) === 0)) {
        initiationTypes = formats;
    }
    const supportedFormats = formats && formats.length > 0 ? formats : ['jwt_vc_json', 'jwt_vc_json-ld', 'ldp_vc'];
    const credentialSupportedOverlap = [];
    if (((opts === null || opts === void 0 ? void 0 : opts.types) && typeof (opts === null || opts === void 0 ? void 0 : opts.types) === 'string') || ((_b = opts === null || opts === void 0 ? void 0 : opts.types) === null || _b === void 0 ? void 0 : _b.length) === 1) {
        const types = Array.isArray(opts.types) ? opts.types[0] : opts.types;
        const supported = credentialsSupported.filter((sup) => sup.id === types || (initiationTypes && arrayEqualsIgnoreOrder(getTypesFromCredentialSupported(sup), initiationTypes)));
        if (supported) {
            credentialSupportedOverlap.push(...supported);
        }
    }
    if (credentialSupportedOverlap.length === 0) {
        // Make sure we include Verifiable Credential both on the offer side as well as in the metadata side, to ensure consistency of the issuer does not.
        if (initiationTypes && !initiationTypes.includes('VerifiableCredential')) {
            initiationTypes.push('VerifiableCredential');
        }
        const supported = credentialsSupported.filter((sup) => {
            const supTypes = getTypesFromCredentialSupported(sup);
            if (!supTypes.includes('VerifiableCredential')) {
                supTypes.push('VerifiableCredential');
            }
            return (!initiationTypes || arrayEqualsIgnoreOrder(supTypes, initiationTypes)) && supportedFormats.includes(sup.format);
        });
        if (supported) {
            credentialSupportedOverlap.push(...supported);
        }
    }
    return credentialSupportedOverlap;
}
exports.getSupportedCredential = getSupportedCredential;
function getTypesFromCredentialSupported(credentialSupported, opts) {
    let types = [];
    if (credentialSupported.format === 'jwt_vc_json' ||
        credentialSupported.format === 'jwt_vc' ||
        credentialSupported.format === 'jwt_vc_json-ld' ||
        credentialSupported.format === 'ldp_vc') {
        types = credentialSupported.types;
    }
    else if (credentialSupported.format === 'vc+sd-jwt') {
        types = [credentialSupported.vct];
    }
    if (!types || types.length === 0) {
        throw Error('Could not deduce types from credential supported');
    }
    if (opts === null || opts === void 0 ? void 0 : opts.filterVerifiableCredential) {
        return types.filter((type) => type !== 'VerifiableCredential');
    }
    return types;
}
exports.getTypesFromCredentialSupported = getTypesFromCredentialSupported;
function arrayEqualsIgnoreOrder(a, b) {
    if (a.length !== b.length)
        return false;
    const uniqueValues = new Set([...a, ...b]);
    for (const v of uniqueValues) {
        const aCount = a.filter((e) => e === v).length;
        const bCount = b.filter((e) => e === v).length;
        if (aCount !== bCount)
            return false;
    }
    return true;
}
function credentialsSupportedV8ToV11(supportedV8) {
    return Object.entries(supportedV8).flatMap((entry) => {
        const type = entry[0];
        const supportedV8 = entry[1];
        return credentialSupportedV8ToV11(type, supportedV8);
    });
}
exports.credentialsSupportedV8ToV11 = credentialsSupportedV8ToV11;
function credentialSupportedV8ToV11(key, supportedV8) {
    return Object.entries(supportedV8.formats).map((entry) => {
        const format = entry[0];
        const credentialSupportBrief = entry[1];
        if (typeof format !== 'string') {
            throw Error(`Unknown format received ${JSON.stringify(format)}`);
        }
        let credentialSupport = {};
        credentialSupport = Object.assign(Object.assign({ format: format, display: supportedV8.display }, credentialSupportBrief), { credentialSubject: supportedV8.claims });
        return credentialSupport;
    });
}
exports.credentialSupportedV8ToV11 = credentialSupportedV8ToV11;
function getIssuerDisplays(metadata, opts) {
    var _a, _b;
    const matchedDisplays = (_b = (_a = metadata.display) === null || _a === void 0 ? void 0 : _a.filter((item) => !(opts === null || opts === void 0 ? void 0 : opts.prefLocales) || opts.prefLocales.length === 0 || (item.locale && opts.prefLocales.includes(item.locale)) || !item.locale)) !== null && _b !== void 0 ? _b : [];
    return matchedDisplays.sort((item) => { var _a; return (item.locale ? (_a = opts === null || opts === void 0 ? void 0 : opts.prefLocales.indexOf(item.locale)) !== null && _a !== void 0 ? _a : 1 : Number.MAX_VALUE); });
}
exports.getIssuerDisplays = getIssuerDisplays;
/**
 * TODO check again when WAL-617 is done to replace how we get the issuer name.
 */
function getIssuerName(url, credentialIssuerMetadata) {
    if (credentialIssuerMetadata) {
        const displays = credentialIssuerMetadata ? getIssuerDisplays(credentialIssuerMetadata) : [];
        for (const display of displays) {
            if (display.name) {
                return display.name;
            }
        }
    }
    return url;
}
exports.getIssuerName = getIssuerName;
//# sourceMappingURL=IssuerMetadataUtils.js.map