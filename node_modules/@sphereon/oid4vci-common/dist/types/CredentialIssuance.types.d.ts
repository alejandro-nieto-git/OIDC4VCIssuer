import { W3CVerifiableCredential } from '@sphereon/ssi-types';
import { AuthzFlowType } from './Authorization.types';
import { OID4VCICredentialFormat } from './Generic.types';
import { OpenId4VCIVersion } from './OpenID4VCIVersions.types';
import { CredentialOfferPayloadV1_0_08 } from './v1_0_08.types';
import { CredentialOfferPayloadV1_0_09, CredentialOfferV1_0_09 } from './v1_0_09.types';
import { CredentialOfferPayloadV1_0_11, CredentialOfferV1_0_11 } from './v1_0_11.types';
export interface CredentialResponse {
    credential?: W3CVerifiableCredential;
    format: OID4VCICredentialFormat;
    transaction_id?: string;
    acceptance_token?: string;
    c_nonce?: string;
    c_nonce_expires_in?: number;
}
export interface CredentialOfferRequestWithBaseUrl extends UniformCredentialOfferRequest {
    scheme: string;
    clientId?: string;
    baseUrl: string;
    userPinRequired: boolean;
    issuerState?: string;
    preAuthorizedCode?: string;
}
export type CredentialOffer = CredentialOfferV1_0_09 | CredentialOfferV1_0_11;
export type CredentialOfferPayload = (CredentialOfferPayloadV1_0_08 | CredentialOfferPayloadV1_0_09 | CredentialOfferPayloadV1_0_11) & {
    [x: string]: any;
};
export interface AssertedUniformCredentialOffer extends UniformCredentialOffer {
    credential_offer: UniformCredentialOfferPayload;
}
export interface UniformCredentialOffer {
    credential_offer?: UniformCredentialOfferPayload;
    credential_offer_uri?: string;
}
export interface UniformCredentialOfferRequest extends AssertedUniformCredentialOffer {
    original_credential_offer: CredentialOfferPayload;
    version: OpenId4VCIVersion;
    supportedFlows: AuthzFlowType[];
}
export type UniformCredentialOfferPayload = CredentialOfferPayloadV1_0_11;
export interface ProofOfPossession {
    proof_type: 'jwt';
    jwt: string;
    [x: string]: unknown;
}
export type SearchValue = {
    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
};
export declare enum JsonURIMode {
    JSON_STRINGIFY = 0,
    X_FORM_WWW_URLENCODED = 1
}
export type EncodeJsonAsURIOpts = {
    uriTypeProperties?: string[];
    arrayTypeProperties?: string[];
    baseUrl?: string;
    param?: string;
    mode?: JsonURIMode;
    version?: OpenId4VCIVersion;
};
export type DecodeURIAsJsonOpts = {
    requiredProperties?: string[];
    arrayTypeProperties?: string[];
};
export interface BaseJWK {
    kty?: string;
    crv?: string;
    x?: string;
    y?: string;
    e?: string;
    n?: string;
}
export interface JWK extends BaseJWK {
    alg?: string;
    d?: string;
    dp?: string;
    dq?: string;
    ext?: boolean;
    k?: string;
    key_ops?: string[];
    kid?: string;
    oth?: Array<{
        d?: string;
        r?: string;
        t?: string;
    }>;
    p?: string;
    q?: string;
    qi?: string;
    use?: string;
    x5c?: string[];
    x5t?: string;
    'x5t#S256'?: string;
    x5u?: string;
    [propName: string]: unknown;
}
export interface Jwt {
    header: JWTHeader;
    payload: JWTPayload;
}
export interface ProofOfPossessionCallbacks<DIDDoc> {
    signCallback: JWTSignerCallback;
    verifyCallback?: JWTVerifyCallback<DIDDoc>;
}
/**
 * Signature algorithms.
 *
 * TODO: Move towards string literal unions and string type, given we do not provide signature/key implementations in this library to begin with
 * @See: https://github.com/Sphereon-Opensource/OID4VCI/issues/88
 */
export declare enum Alg {
    EdDSA = "EdDSA",
    ES256 = "ES256",
    ES256K = "ES256K",
    PS256 = "PS256",
    PS384 = "PS384",
    PS512 = "PS512",
    RS256 = "RS256",
    RS384 = "RS384",
    RS512 = "RS512"
}
export type Typ = 'jwt' | 'openid4vci-proof+jwt';
export interface JoseHeaderParameters {
    kid?: string;
    x5t?: string;
    x5c?: string[];
    x5u?: string;
    jku?: string;
    jwk?: BaseJWK;
    typ?: string;
    cty?: string;
}
export interface JWSHeaderParameters extends JoseHeaderParameters {
    alg?: Alg | string;
    b64?: boolean;
    crit?: string[];
    [propName: string]: unknown;
}
export interface CompactJWSHeaderParameters extends JWSHeaderParameters {
    alg: string;
}
export interface JWTHeaderParameters extends CompactJWSHeaderParameters {
    b64?: true;
}
export type JWTHeader = JWTHeaderParameters;
export interface JWTPayload {
    iss?: string;
    aud?: string | string[];
    iat?: number;
    nonce?: string;
    jti?: string;
    exp?: number;
    [s: string]: unknown;
}
export type JWTSignerCallback = (jwt: Jwt, kid?: string) => Promise<string>;
export type JWTVerifyCallback<DIDDoc> = (args: {
    jwt: string;
    kid?: string;
}) => Promise<JwtVerifyResult<DIDDoc>>;
export interface JwtVerifyResult<DIDDoc> {
    jwt: Jwt;
    kid?: string;
    alg: string;
    did?: string;
    didDocument?: DIDDoc;
    x5c?: string;
    jwk?: BaseJWK;
}
//# sourceMappingURL=CredentialIssuance.types.d.ts.map