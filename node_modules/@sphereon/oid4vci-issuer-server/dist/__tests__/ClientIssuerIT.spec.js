"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDid = void 0;
const didKeyDriver = __importStar(require("@digitalcredentials/did-method-key"));
const oid4vci_client_1 = require("@sphereon/oid4vci-client");
const oid4vci_common_1 = require("@sphereon/oid4vci-common");
const builder_1 = require("@sphereon/oid4vci-issuer/dist/builder");
const state_manager_1 = require("@sphereon/oid4vci-issuer/dist/state-manager");
const ssi_express_support_1 = require("@sphereon/ssi-express-support");
const ssi_types_1 = require("@sphereon/ssi-types");
const jose = __importStar(require("jose"));
const OID4VCIServer_1 = require("../OID4VCIServer");
const ISSUER_URL = 'http://localhost:3456/test';
let expressSupport;
let subjectKeypair; // Proof of Possession JWT
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let subjectDIDKey; // Json LD VC issuance
const generateDid = () => __awaiter(void 0, void 0, void 0, function* () {
    const didKD = didKeyDriver.driver();
    const { didDocument, keyPairs, methodFor } = yield didKD.generate();
    return { didDocument, keyPairs, methodFor };
});
exports.generateDid = generateDid;
jest.setTimeout(15000);
describe('VcIssuer', () => {
    let vcIssuer;
    let server;
    let accessToken;
    const issuerState = 'previously-created-state';
    // const clientId = 'sphereon:wallet'
    const preAuthorizedCode = 'test_code';
    /*const preAuthorizedCode1 = 'SplxlOBeZQQYbYS6WxSbIA1'
    const preAuthorizedCode2 = 'SplxlOBeZQQYbYS6WxSbIA2'
    const preAuthorizedCode3 = 'SplxlOBeZQQYbYS6WxSbIA3'
  */
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        jest.clearAllMocks();
        const { privateKey, publicKey } = yield jose.generateKeyPair('ES256');
        subjectKeypair = { publicKey: publicKey, privateKey: privateKey };
        subjectDIDKey = yield (0, exports.generateDid)();
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const accessTokenSignerCallback = (jwt, kid) => __awaiter(void 0, void 0, void 0, function* () {
            const privateKey = (yield jose.generateKeyPair(oid4vci_common_1.Alg.ES256)).privateKey;
            return new jose.SignJWT(Object.assign({}, jwt.payload)).setProtectedHeader(Object.assign(Object.assign({}, jwt.header), { alg: oid4vci_common_1.Alg.ES256 })).sign(privateKey);
        });
        const credentialsSupported = new builder_1.CredentialSupportedBuilderV1_11()
            .withCryptographicSuitesSupported('ES256K')
            .withCryptographicBindingMethod('did')
            .withTypes('VerifiableCredential')
            .withFormat('jwt_vc_json')
            .withId('UniversityDegree_JWT')
            .withCredentialSupportedDisplay({
            name: 'University Credential',
            locale: 'en-US',
            logo: {
                url: 'https://exampleuniversity.com/public/logo.png',
                alt_text: 'a square logo of a university',
            },
            background_color: '#12107c',
            text_color: '#FFFFFF',
        })
            .addCredentialSubjectPropertyDisplay('given_name', {
            name: 'given name',
            locale: 'en-US',
        })
            .build();
        const stateManager = new state_manager_1.MemoryStates();
        const credential = {
            '@context': ['https://www.w3.org/2018/credentials/v1'],
            type: ['VerifiableCredential'],
            issuer: 'did:key:test',
            issuanceDate: new Date().toISOString(),
            credentialSubject: {},
        };
        vcIssuer = new builder_1.VcIssuerBuilder()
            // .withAuthorizationServer('https://authorization-server')
            .withCredentialEndpoint('http://localhost:3456/test/credential-endpoint')
            .withDefaultCredentialOfferBaseUri('http://localhost:3456/test')
            .withCredentialIssuer(ISSUER_URL)
            .withIssuerDisplay({
            name: 'example issuer',
            locale: 'en-US',
        })
            .withCredentialsSupported(credentialsSupported)
            .withCredentialOfferStateManager(stateManager)
            .withInMemoryCNonceState()
            .withInMemoryCredentialOfferURIState()
            .withCredentialDataSupplier(() => Promise.resolve({
            format: 'ldp_vc',
            credential,
        }))
            .withCredentialSignerCallback(() => Promise.resolve(Object.assign(Object.assign({}, credential), { proof: {
                type: ssi_types_1.IProofType.JwtProof2020,
                jwt: 'ye.ye.ye',
                created: new Date().toISOString(),
                proofPurpose: ssi_types_1.IProofPurpose.assertionMethod,
                verificationMethod: 'sdfsdfasdfasdfasdfasdfassdfasdf',
            } })))
            .withJWTVerifyCallback((args) => {
            var _a, _b;
            const header = jose.decodeProtectedHeader(args.jwt);
            const payload = jose.decodeJwt(args.jwt);
            const kid = (_a = header.kid) !== null && _a !== void 0 ? _a : args.kid;
            const did = kid.split('#')[0];
            const didDocument = {
                '@context': 'https://www.w3.org/ns/did/v1',
                id: did,
            };
            const alg = (_b = header.alg) !== null && _b !== void 0 ? _b : 'ES256k';
            return Promise.resolve({
                alg,
                kid,
                did,
                didDocument,
                jwt: {
                    header: header,
                    payload: payload,
                },
            });
        })
            .build();
        expressSupport = ssi_express_support_1.ExpressBuilder.fromServerOpts({
            port: 3456,
            hostname: 'localhost',
        }).build({ startListening: false });
        server = new OID4VCIServer_1.OID4VCIServer(expressSupport, {
            issuer: vcIssuer,
            baseUrl: 'http://localhost:3456/test',
            endpointOpts: {
                // serverOpts: { baseUrl: 'http://localhost:3456/test', port: 3456 },
                tokenEndpointOpts: { accessTokenSignerCallback, tokenPath: '/test/token' },
            },
        });
        expressSupport.start();
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        jest.clearAllMocks();
        yield server.stop();
        // await new Promise((resolve) => setTimeout((v: void) => resolve(v), 500))
    }));
    let credOfferSession;
    let uri;
    let client;
    it('should create credential offer', () => __awaiter(void 0, void 0, void 0, function* () {
        expect(server.issuer).toBeDefined();
        uri = yield vcIssuer
            .createCredentialOfferURI({
            grants: {
                authorization_code: {
                    issuer_state: issuerState,
                },
                'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                    'pre-authorized_code': preAuthorizedCode,
                    user_pin_required: true,
                },
            },
            credentials: ['UniversityDegree_JWT'],
            scheme: 'http',
        })
            .then((response) => response.uri);
        expect(uri).toEqual('http://localhost:3456/test?credential_offer=%7B%22grants%22%3A%7B%22authorization_code%22%3A%7B%22issuer_state%22%3A%22previously-created-state%22%7D%2C%22urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Apre-authorized_code%22%3A%7B%22pre-authorized_code%22%3A%22test_code%22%2C%22user_pin_required%22%3Atrue%7D%7D%2C%22credentials%22%3A%5B%22UniversityDegree_JWT%22%5D%2C%22credential_issuer%22%3A%22http%3A%2F%2Flocalhost%3A3456%2Ftest%22%7D');
    }));
    it('should create client from credential offer URI', () => __awaiter(void 0, void 0, void 0, function* () {
        client = yield oid4vci_client_1.OpenID4VCIClient.fromURI({
            uri,
            kid: subjectDIDKey.didDocument.authentication[0],
            alg: 'ES256',
            createAuthorizationRequestURL: false,
        });
        expect(client.credentialOffer).toEqual({
            baseUrl: 'http://localhost:3456/test',
            credential_offer: {
                credential_issuer: 'http://localhost:3456/test',
                credentials: ['UniversityDegree_JWT'],
                grants: {
                    authorization_code: {
                        issuer_state: 'previously-created-state',
                    },
                    'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                        'pre-authorized_code': 'test_code',
                        user_pin_required: true,
                    },
                },
            },
            issuerState: 'previously-created-state',
            original_credential_offer: {
                credential_issuer: 'http://localhost:3456/test',
                credentials: ['UniversityDegree_JWT'],
                grants: {
                    authorization_code: {
                        issuer_state: 'previously-created-state',
                    },
                    'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                        'pre-authorized_code': 'test_code',
                        user_pin_required: true,
                    },
                },
            },
            preAuthorizedCode: 'test_code',
            scheme: 'http',
            supportedFlows: ['Authorization Code Flow', 'Pre-Authorized Code Flow'],
            userPinRequired: true,
            version: 1011,
        });
        expect(client.getIssuer()).toEqual(ISSUER_URL);
        expect(client.version()).toEqual(oid4vci_common_1.OpenId4VCIVersion.VER_1_0_11);
    }));
    it('should retrieve server metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        yield expect(client.retrieveServerMetadata()).resolves.toEqual({
            authorizationServerType: 'OID4VCI',
            authorization_server: 'http://localhost:3456/test',
            credentialIssuerMetadata: {
                credential_endpoint: 'http://localhost:3456/test/credential-endpoint',
                credential_issuer: 'http://localhost:3456/test',
                credentials_supported: [
                    {
                        credentialSubject: {
                            given_name: {
                                locale: 'en-US',
                                name: 'given name',
                            },
                        },
                        cryptographic_binding_methods_supported: ['did'],
                        cryptographic_suites_supported: ['ES256K'],
                        display: [
                            {
                                background_color: '#12107c',
                                locale: 'en-US',
                                logo: {
                                    alt_text: 'a square logo of a university',
                                    url: 'https://exampleuniversity.com/public/logo.png',
                                },
                                name: 'University Credential',
                                text_color: '#FFFFFF',
                            },
                        ],
                        format: 'jwt_vc_json',
                        id: 'UniversityDegree_JWT',
                        types: ['VerifiableCredential'],
                    },
                ],
                display: [
                    {
                        locale: 'en-US',
                        name: 'example issuer',
                    },
                ],
            },
            credential_endpoint: 'http://localhost:3456/test/credential-endpoint',
            issuer: 'http://localhost:3456/test',
            token_endpoint: 'http://localhost:3456/test/token',
        });
    }));
    it('should get state on server side', () => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        const preAuthCode = (_b = (_a = client.credentialOffer.credential_offer.grants) === null || _a === void 0 ? void 0 : _a['urn:ietf:params:oauth:grant-type:pre-authorized_code']) === null || _b === void 0 ? void 0 : _b['pre-authorized_code'];
        expect(preAuthCode).toBeDefined();
        if (preAuthCode) {
            credOfferSession = yield vcIssuer.credentialOfferSessions.getAsserted(preAuthCode);
        }
        expect(credOfferSession).toBeDefined();
    }));
    it('should acquire access token', () => __awaiter(void 0, void 0, void 0, function* () {
        accessToken = yield client.acquireAccessToken({ pin: credOfferSession.userPin });
        expect(accessToken).toBeDefined();
    }));
    it('should issue credential', () => __awaiter(void 0, void 0, void 0, function* () {
        function proofOfPossessionCallbackFunction(args, kid) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield new jose.SignJWT(Object.assign({}, args.payload))
                    .setProtectedHeader(Object.assign({}, args.header))
                    .setIssuedAt(+new Date())
                    .setIssuer(kid)
                    .setAudience(args.payload.aud)
                    .setExpirationTime('2h')
                    .sign(subjectKeypair.privateKey);
            });
        }
        const credentialResponse = yield client.acquireCredentials({
            credentialTypes: ['VerifiableCredential'],
            format: 'jwt_vc_json',
            proofCallbacks: { signCallback: proofOfPossessionCallbackFunction },
        });
        expect(credentialResponse).toMatchObject({
            c_nonce_expires_in: 300,
            credential: {
                '@context': ['https://www.w3.org/2018/credentials/v1'],
                credentialSubject: {},
                issuer: 'did:key:test',
                proof: {
                    jwt: 'ye.ye.ye',
                    proofPurpose: 'assertionMethod',
                    type: 'JwtProof2020',
                    verificationMethod: 'sdfsdfasdfasdfasdfasdfassdfasdf',
                },
                type: ['VerifiableCredential'],
            },
            format: 'jwt_vc_json',
        });
    }));
});
