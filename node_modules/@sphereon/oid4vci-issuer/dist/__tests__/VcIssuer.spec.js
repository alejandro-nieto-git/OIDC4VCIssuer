"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const oid4vci_client_1 = require("@sphereon/oid4vci-client");
const oid4vci_common_1 = require("@sphereon/oid4vci-common");
const ssi_types_1 = require("@sphereon/ssi-types");
const builder_1 = require("../builder");
const state_manager_1 = require("../state-manager");
const IDENTIPROOF_ISSUER_URL = 'https://issuer.research.identiproof.io';
const verifiableCredential = {
    '@context': ['https://www.w3.org/2018/credentials/v1', 'https://w3id.org/security/suites/jws-2020/v1'],
    id: 'http://university.example/credentials/1872',
    type: ['VerifiableCredential', 'ExampleAlumniCredential'],
    issuer: 'https://university.example/issuers/565049',
    issuanceDate: new Date().toISOString(),
    credentialSubject: {
        id: 'did:example:ebfeb1f712ebc6f1c276e12ec21',
        alumniOf: {
            id: 'did:example:c276e12ec21ebfeb1f712ebc6f1',
            name: 'Example University',
        },
    },
};
describe('VcIssuer', () => {
    let vcIssuer;
    const issuerState = 'previously-created-state';
    const clientId = 'sphereon:wallet';
    const preAuthorizedCode = 'test_code';
    const jwtVerifyCallback = jest.fn();
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        jest.clearAllMocks();
        const credentialsSupported = new builder_1.CredentialSupportedBuilderV1_11()
            .withCryptographicSuitesSupported('ES256K')
            .withCryptographicBindingMethod('did')
            .withFormat('jwt_vc_json')
            .withTypes('VerifiableCredential')
            .withId('UniversityDegree_JWT')
            .withCredentialSupportedDisplay({
            name: 'University Credential',
            locale: 'en-US',
            logo: {
                url: 'https://exampleuniversity.com/public/logo.png',
                alt_text: 'a square logo of a university',
            },
            background_color: '#12107c',
            text_color: '#FFFFFF',
        })
            .addCredentialSubjectPropertyDisplay('given_name', {
            name: 'given name',
            locale: 'en-US',
        })
            .build();
        const stateManager = new state_manager_1.MemoryStates();
        yield stateManager.set('previously-created-state', {
            issuerState,
            clientId,
            preAuthorizedCode,
            createdAt: +new Date(),
            lastUpdatedAt: +new Date(),
            status: oid4vci_common_1.IssueStatus.OFFER_CREATED,
            userPin: '123456',
            credentialOffer: {
                credential_offer: {
                    credential_issuer: 'did:key:test',
                    credentials: [
                        {
                            format: 'ldp_vc',
                            credential_definition: {
                                types: ['VerifiableCredential'],
                                '@context': ['https://www.w3.org/2018/credentials/v1'],
                                credentialSubject: {},
                            },
                        },
                    ],
                    grants: {
                        authorization_code: { issuer_state: issuerState },
                        'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                            'pre-authorized_code': preAuthorizedCode,
                            user_pin_required: true,
                        },
                    },
                },
            },
        });
        vcIssuer = new builder_1.VcIssuerBuilder()
            .withAuthorizationServer('https://authorization-server')
            .withCredentialEndpoint('https://credential-endpoint')
            .withCredentialIssuer(IDENTIPROOF_ISSUER_URL)
            .withIssuerDisplay({
            name: 'example issuer',
            locale: 'en-US',
        })
            .withCredentialsSupported(credentialsSupported)
            .withCredentialOfferStateManager(stateManager)
            .withInMemoryCNonceState()
            .withInMemoryCredentialOfferURIState()
            .withCredentialSignerCallback(() => Promise.resolve({
            '@context': ['https://www.w3.org/2018/credentials/v1'],
            type: ['VerifiableCredential'],
            issuer: 'did:key:test',
            issuanceDate: new Date().toISOString(),
            credentialSubject: {},
            proof: {
                type: ssi_types_1.IProofType.JwtProof2020,
                jwt: 'ye.ye.ye',
                created: new Date().toISOString(),
                proofPurpose: ssi_types_1.IProofPurpose.assertionMethod,
                verificationMethod: 'sdfsdfasdfasdfasdfasdfassdfasdf',
            },
        }))
            .withJWTVerifyCallback(jwtVerifyCallback)
            .build();
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        jest.clearAllMocks();
        // await new Promise((resolve) => setTimeout((v: void) => resolve(v), 500))
    }));
    it.skip('should create credential offer', () => __awaiter(void 0, void 0, void 0, function* () {
        const _a = yield vcIssuer.createCredentialOfferURI({
            grants: {
                authorization_code: {
                    issuer_state: issuerState,
                },
                'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                    'pre-authorized_code': preAuthorizedCode,
                    user_pin_required: true,
                },
            },
            scheme: 'http',
            baseUri: 'issuer-example.com',
            qrCodeOpts: {
                size: 400,
                colorDark: '#000000',
                colorLight: '#ffffff',
                correctLevel: 2,
            },
        }), { uri } = _a, rest = __rest(_a, ["uri"]);
        console.log(JSON.stringify(rest, null, 2));
        expect(uri).toEqual('http://issuer-example.com?credential_offer=%7B%22grants%22%3A%7B%22authorization_code%22%3A%7B%22issuer_state%22%3A%22previously-created-state%22%7D%2C%22urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Apre-authorized_code%22%3A%7B%22pre-authorized_code%22%3A%22test_code%22%2C%22user_pin_required%22%3Atrue%7D%7D%2C%22credential_issuer%22%3A%22https%3A%2F%2Fissuer.research.identiproof.io%22%2C%22credentials%22%3A%5B%7B%22format%22%3A%22jwt_vc_json%22%2C%22types%22%3A%5B%22VerifiableCredential%22%5D%2C%22credentialSubject%22%3A%7B%22given_name%22%3A%7B%22name%22%3A%22given%20name%22%2C%22locale%22%3A%22en-US%22%7D%7D%2C%22cryptographic_suites_supported%22%3A%5B%22ES256K%22%5D%2C%22cryptographic_binding_methods_supported%22%3A%5B%22did%22%5D%2C%22id%22%3A%22UniversityDegree_JWT%22%2C%22display%22%3A%5B%7B%22name%22%3A%22University%20Credential%22%2C%22locale%22%3A%22en-US%22%2C%22logo%22%3A%7B%22url%22%3A%22https%3A%2F%2Fexampleuniversity.com%2Fpublic%2Flogo.png%22%2C%22alt_text%22%3A%22a%20square%20logo%20of%20a%20university%22%7D%2C%22background_color%22%3A%22%2312107c%22%2C%22text_color%22%3A%22%23FFFFFF%22%7D%5D%7D%5D%7D');
        const client = yield oid4vci_client_1.OpenID4VCIClient.fromURI({ uri });
        expect(client.credentialOffer).toEqual({
            baseUrl: 'http://issuer-example.com',
            credential_offer: {
                credential_issuer: 'https://issuer.research.identiproof.io',
                credentials: [
                    {
                        credentialSubject: {
                            given_name: {
                                locale: 'en-US',
                                name: 'given name',
                            },
                        },
                        cryptographic_binding_methods_supported: ['did'],
                        cryptographic_suites_supported: ['ES256K'],
                        display: [
                            {
                                background_color: '#12107c',
                                locale: 'en-US',
                                logo: {
                                    alt_text: 'a square logo of a university',
                                    url: 'https://exampleuniversity.com/public/logo.png',
                                },
                                name: 'University Credential',
                                text_color: '#FFFFFF',
                            },
                        ],
                        format: 'jwt_vc_json',
                        id: 'UniversityDegree_JWT',
                        types: ['VerifiableCredential'],
                    },
                ],
                grants: {
                    authorization_code: {
                        issuer_state: 'previously-created-state',
                    },
                    'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                        'pre-authorized_code': 'test_code',
                        user_pin_required: true,
                    },
                },
            },
            issuerState: 'previously-created-state',
            original_credential_offer: {
                credential_issuer: 'https://issuer.research.identiproof.io',
                credentials: [
                    {
                        credentialSubject: {
                            given_name: {
                                locale: 'en-US',
                                name: 'given name',
                            },
                        },
                        cryptographic_binding_methods_supported: ['did'],
                        cryptographic_suites_supported: ['ES256K'],
                        display: [
                            {
                                background_color: '#12107c',
                                locale: 'en-US',
                                logo: {
                                    alt_text: 'a square logo of a university',
                                    url: 'https://exampleuniversity.com/public/logo.png',
                                },
                                name: 'University Credential',
                                text_color: '#FFFFFF',
                            },
                        ],
                        format: 'jwt_vc_json',
                        id: 'UniversityDegree_JWT',
                        types: ['VerifiableCredential'],
                    },
                ],
                grants: {
                    authorization_code: {
                        issuer_state: 'previously-created-state',
                    },
                    'urn:ietf:params:oauth:grant-type:pre-authorized_code': {
                        'pre-authorized_code': 'test_code',
                        user_pin_required: true,
                    },
                },
            },
            preAuthorizedCode: 'test_code',
            scheme: 'http',
            supportedFlows: ['Authorization Code Flow', 'Pre-Authorized Code Flow'],
            userPinRequired: true,
            version: 1011,
        });
    }));
    it('should create credential offer uri', () => __awaiter(void 0, void 0, void 0, function* () {
        yield expect(vcIssuer
            .createCredentialOfferURI({
            grants: {
                authorization_code: {
                    issuer_state: issuerState,
                },
            },
            scheme: 'http',
            baseUri: 'issuer-example.com',
            credentials: [''],
            credentialOfferUri: 'https://somehost.com/offer-id',
        })
            .then((response) => response.uri)).resolves.toEqual('http://issuer-example.com?credential_offer_uri=https://somehost.com/offer-id');
    }));
    // Of course this doesn't work. The state is part of the proof to begin with
    it('should fail issuing credential if an invalid state is used', () => __awaiter(void 0, void 0, void 0, function* () {
        jwtVerifyCallback.mockResolvedValue({
            did: 'did:example:1234',
            kid: 'did:example:1234#auth',
            alg: oid4vci_common_1.Alg.ES256K,
            didDocument: {
                '@context': 'https://www.w3.org/ns/did/v1',
                id: 'did:example:1234',
            },
            jwt: {
                header: {
                    typ: 'openid4vci-proof+jwt',
                    alg: oid4vci_common_1.Alg.ES256K,
                    kid: 'test-kid',
                },
                payload: {
                    aud: IDENTIPROOF_ISSUER_URL,
                    iat: +new Date(),
                    nonce: 'test-nonce',
                },
            },
        });
        yield expect(vcIssuer.issueCredential({
            credentialRequest: {
                types: ['VerifiableCredential'],
                format: 'jwt_vc_json',
                proof: {
                    proof_type: 'jwt',
                    jwt: 'ye.ye.ye',
                },
            },
            // issuerState: 'invalid state',
        })).rejects.toThrow(Error(oid4vci_common_1.STATE_MISSING_ERROR + ' (test-nonce)'));
    }));
    it.each([...Object.values(oid4vci_common_1.Alg), 'CUSTOM'])('should issue %s signed credential if a valid state is passed in', (alg) => __awaiter(void 0, void 0, void 0, function* () {
        jwtVerifyCallback.mockResolvedValue({
            did: 'did:example:1234',
            kid: 'did:example:1234#auth',
            alg: alg,
            didDocument: {
                '@context': 'https://www.w3.org/ns/did/v1',
                id: 'did:example:1234',
            },
            jwt: {
                header: {
                    typ: 'openid4vci-proof+jwt',
                    alg: alg,
                    kid: 'test-kid',
                },
                payload: {
                    aud: IDENTIPROOF_ISSUER_URL,
                    iat: +new Date(),
                    nonce: 'test-nonce',
                },
            },
        });
        const createdAt = +new Date();
        yield vcIssuer.cNonces.set('test-nonce', {
            cNonce: 'test-nonce',
            preAuthorizedCode: 'test-pre-authorized-code',
            createdAt: createdAt,
        });
        yield vcIssuer.credentialOfferSessions.set('test-pre-authorized-code', {
            createdAt: createdAt,
            preAuthorizedCode: 'test-pre-authorized-code',
            credentialOffer: {
                credential_offer: {
                    credential_issuer: 'did:key:test',
                    credentials: [],
                },
            },
            lastUpdatedAt: createdAt,
            status: oid4vci_common_1.IssueStatus.ACCESS_TOKEN_CREATED,
        });
        expect(vcIssuer.issueCredential({
            credential: verifiableCredential,
            credentialRequest: {
                types: ['VerifiableCredential'],
                format: 'jwt_vc_json',
                proof: {
                    proof_type: 'jwt',
                    jwt: 'ye.ye.ye',
                },
            },
            newCNonce: 'new-test-nonce',
        })).resolves.toEqual({
            c_nonce: 'new-test-nonce',
            c_nonce_expires_in: 300,
            credential: {
                '@context': ['https://www.w3.org/2018/credentials/v1'],
                credentialSubject: {},
                issuanceDate: expect.any(String),
                issuer: 'did:key:test',
                proof: {
                    created: expect.any(String),
                    jwt: 'ye.ye.ye',
                    proofPurpose: 'assertionMethod',
                    type: 'JwtProof2020',
                    verificationMethod: 'sdfsdfasdfasdfasdfasdfassdfasdf',
                },
                type: ['VerifiableCredential'],
            },
            format: 'jwt_vc_json',
        });
    }));
    it('should fail issuing credential if the signing algorithm is missing', () => __awaiter(void 0, void 0, void 0, function* () {
        const createdAt = +new Date();
        yield vcIssuer.cNonces.set('test-nonce', {
            cNonce: 'test-nonce',
            preAuthorizedCode: 'test-pre-authorized-code',
            createdAt: createdAt,
        });
        jwtVerifyCallback.mockResolvedValue({
            did: 'did:example:1234',
            kid: 'did:example:1234#auth',
            alg: undefined,
            didDocument: {
                '@context': 'https://www.w3.org/ns/did/v1',
                id: 'did:example:1234',
            },
            jwt: {
                header: {
                    typ: 'openid4vci-proof+jwt',
                    alg: undefined,
                    kid: 'test-kid',
                },
                payload: {
                    aud: IDENTIPROOF_ISSUER_URL,
                    iat: +new Date(),
                    nonce: 'test-nonce',
                },
            },
        });
        expect(vcIssuer.issueCredential({
            credentialRequest: {
                types: ['VerifiableCredential'],
                format: 'jwt_vc_json',
                proof: {
                    proof_type: 'jwt',
                    jwt: 'ye.ye.ye',
                },
            },
        })).rejects.toThrow(Error(oid4vci_common_1.ALG_ERROR));
    }));
});
//# sourceMappingURL=VcIssuer.spec.js.map