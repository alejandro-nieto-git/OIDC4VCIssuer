"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertValidPinNumber = exports.isPreAuthorizedCodeExpired = exports.createCredentialOfferURI = exports.createCredentialOfferURIFromObject = exports.createCredentialOfferObject = void 0;
const oid4vci_common_1 = require("@sphereon/oid4vci-common");
const uuid_1 = require("uuid");
function createCredentialOfferObject(issuerMetadata, 
// todo: probably it's wise to create another builder for CredentialOfferPayload that will generate different kinds of CredentialOfferPayload
opts) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!issuerMetadata && !(opts === null || opts === void 0 ? void 0 : opts.credentialOffer) && !(opts === null || opts === void 0 ? void 0 : opts.credentialOfferUri)) {
        throw new Error('You have to provide issuerMetadata or credentialOffer object for creating a deeplink');
    }
    const scheme = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.scheme) === null || _a === void 0 ? void 0 : _a.replace('://', '')) !== null && _b !== void 0 ? _b : (((_c = opts === null || opts === void 0 ? void 0 : opts.baseUri) === null || _c === void 0 ? void 0 : _c.includes('://')) ? opts.baseUri.split('://')[0] : 'openid-credential-offer');
    let baseUri;
    if (opts === null || opts === void 0 ? void 0 : opts.baseUri) {
        baseUri = opts.baseUri;
    }
    else if (scheme.startsWith('http')) {
        if (issuerMetadata === null || issuerMetadata === void 0 ? void 0 : issuerMetadata.credential_issuer) {
            baseUri = issuerMetadata === null || issuerMetadata === void 0 ? void 0 : issuerMetadata.credential_issuer;
            if (!baseUri.startsWith(`${scheme}://`)) {
                throw Error(`scheme ${scheme} is different from base uri ${baseUri}`);
            }
        }
        else {
            throw Error(`A '${scheme}' scheme requires a URI to be present as baseUri`);
        }
    }
    else {
        baseUri = '';
    }
    baseUri = baseUri.replace(`${scheme}://`, '');
    const credential_offer_uri = (opts === null || opts === void 0 ? void 0 : opts.credentialOfferUri) ? `${scheme}://${baseUri}?credential_offer_uri=${opts === null || opts === void 0 ? void 0 : opts.credentialOfferUri}` : undefined;
    let credential_offer;
    if (opts === null || opts === void 0 ? void 0 : opts.credentialOffer) {
        credential_offer = Object.assign(Object.assign({}, opts.credentialOffer), { credentials: (_e = (_d = opts.credentialOffer) === null || _d === void 0 ? void 0 : _d.credentials) !== null && _e !== void 0 ? _e : issuerMetadata === null || issuerMetadata === void 0 ? void 0 : issuerMetadata.credentials_supported });
    }
    else {
        credential_offer = {
            credential_issuer: issuerMetadata === null || issuerMetadata === void 0 ? void 0 : issuerMetadata.credential_issuer,
            credentials: issuerMetadata === null || issuerMetadata === void 0 ? void 0 : issuerMetadata.credentials_supported,
        };
    }
    // todo: check payload against issuer metadata. Especially strings in the credentials array: When processing, the Wallet MUST resolve this string value to the respective object.
    if (!credential_offer.grants) {
        credential_offer.grants = {};
    }
    if (opts === null || opts === void 0 ? void 0 : opts.preAuthorizedCode) {
        credential_offer.grants['urn:ietf:params:oauth:grant-type:pre-authorized_code'] = {
            'pre-authorized_code': opts.preAuthorizedCode,
            user_pin_required: opts.userPinRequired ? opts.userPinRequired : false,
        };
    }
    else if (!((_g = (_f = credential_offer.grants) === null || _f === void 0 ? void 0 : _f.authorization_code) === null || _g === void 0 ? void 0 : _g.issuer_state)) {
        credential_offer.grants = {
            authorization_code: {
                issuer_state: (_h = opts === null || opts === void 0 ? void 0 : opts.issuerState) !== null && _h !== void 0 ? _h : (0, uuid_1.v4)(),
            },
        };
    }
    return { credential_offer, credential_offer_uri, scheme, baseUri, grants: credential_offer.grants };
}
exports.createCredentialOfferObject = createCredentialOfferObject;
function createCredentialOfferURIFromObject(credentialOffer, opts) {
    var _a, _b, _c, _d, _e, _f;
    const scheme = (_d = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.scheme) === null || _a === void 0 ? void 0 : _a.replace('://', '')) !== null && _b !== void 0 ? _b : (_c = credentialOffer === null || credentialOffer === void 0 ? void 0 : credentialOffer.scheme) === null || _c === void 0 ? void 0 : _c.replace('://', '')) !== null && _d !== void 0 ? _d : 'openid-credential-offer';
    let baseUri = (_f = (_e = opts === null || opts === void 0 ? void 0 : opts.baseUri) !== null && _e !== void 0 ? _e : credentialOffer === null || credentialOffer === void 0 ? void 0 : credentialOffer.baseUri) !== null && _f !== void 0 ? _f : '';
    if (baseUri.includes('://')) {
        baseUri = baseUri.split('://')[1];
    }
    if (scheme.startsWith('http') && baseUri === '') {
        throw Error(`Cannot use scheme '${scheme}' without providing a baseUri value`);
    }
    if (credentialOffer.credential_offer_uri) {
        if (credentialOffer.credential_offer_uri.includes('credential_offer_uri=')) {
            // discard the scheme. Apparently a URI is set and it already contains the actual uri, so assume that takes priority
            return credentialOffer.credential_offer_uri;
        }
        return `${scheme}://${baseUri}?credential_offer_uri=${credentialOffer.credential_offer_uri}`;
    }
    return `${scheme}://${baseUri}?credential_offer=${encodeURIComponent(JSON.stringify(credentialOffer.credential_offer))}`;
}
exports.createCredentialOfferURIFromObject = createCredentialOfferURIFromObject;
function createCredentialOfferURI(issuerMetadata, 
// todo: probably it's wise to create another builder for CredentialOfferPayload that will generate different kinds of CredentialOfferPayload
opts) {
    const credentialOffer = createCredentialOfferObject(issuerMetadata, opts);
    return createCredentialOfferURIFromObject(credentialOffer, opts);
}
exports.createCredentialOfferURI = createCredentialOfferURI;
const isPreAuthorizedCodeExpired = (state, expirationDuration) => {
    const now = +new Date();
    const expirationTime = state.createdAt + expirationDuration;
    return now >= expirationTime;
};
exports.isPreAuthorizedCodeExpired = isPreAuthorizedCodeExpired;
const assertValidPinNumber = (pin) => {
    if (pin && !/[0-9{,8}]/.test(pin)) {
        throw Error(oid4vci_common_1.PIN_VALIDATION_ERROR);
    }
};
exports.assertValidPinNumber = assertValidPinNumber;
//# sourceMappingURL=CredentialOfferUtils.js.map